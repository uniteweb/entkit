{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

 



var ErrOptimisticLock = errors.New("optimistic lock conflictã€‚")

{{- range $node := .Nodes}}
    {{- if hasVersionField $node }}
// Code generated by entkit . DO NOT EDIT.
// UpdateOneWithLock updates a single {{ $node.Name }} entity by ID with optimistic lock.
func ({{$node.Receiver}} *{{$node.Name}}Client) UpdateOneWithLock(ctx context.Context, id {{ idType $node}}, version  int, fn func(*{{ $node.Name}}UpdateOne) *{{ $node.Name}}UpdateOne ) error {

   	err := fn({{$node.Receiver}}.UpdateOneID(id).Where({{ $node.Name | lower }}.VersionEQ(version)).SetVersion(version + 1)).Exec(ctx)
    if IsNotFound(err) {
        return ErrOptimisticLock
    }
    return err
}
        {{- if genRetry }}

// Code generated by entkit , DO NOT EDIT.
// UpdateOneWithLockAndRetry updates a single {{ $node.Name }} entity by ID with optimistic lock, and retry with a specified number of times.
func ({{$node.Receiver}} *{{$node.Name}}Client) UpdateOneWithLockAndRetry(ctx context.Context, id {{ idType $node}}, version  int, fn func(*{{ $node.Name}}UpdateOne) *{{ $node.Name}}UpdateOne, retryCount int,  retryDuration time.Duration ) error {
    var err error 

    for i := 0; i < retryCount; i ++ {
        err = {{$node.Receiver}}.UpdateOneWithLock(ctx, id, version, fn)

        if !errors.Is(err, ErrOptimisticLock) {
            return err 
        }

        // Sleep for a while before retry, to avoid the lock being held by other goroutines
        time.Sleep(retryDuration)
    }
    return err 
}

        {{- end }}
    {{- end }}
{{- end }}